[
  {
    "milestone": 1,
    "goal": "pnpm workspace + Next.js App Router プロジェクトが起動し、Biome lint / typecheck / build が通り、shadcn/ui + Tailwind CSS でレイアウト（サイドバー + ヘッダー）が表示され、Prisma スキーマに全テーブルが定義されて prisma generate が成功する",
    "verification": "pnpm lint && pnpm typecheck && pnpm build",
    "done": true,
    "tasks": [
      {
        "id": "project-scaffold",
        "description": "pnpm workspace + Next.js App Router プロジェクトの初期構築。ルート package.json（workspace scripts: lint, typecheck, build）、pnpm-workspace.yaml、apps/content-reviewer/ 配下に package.json・next.config.ts・tsconfig.json・tailwind.config.ts・postcss.config.mjs・biome.json を作成し、Tailwind CSS v4 + PostCSS を設定、apps/content-reviewer/src/app/globals.css に Tailwind ディレクティブを記述、最小限の app/layout.tsx と app/page.tsx で pnpm build が通る状態にする",
        "wave": 1,
        "done": true
      },
      {
        "id": "shadcn-ui-setup",
        "description": "apps/content-reviewer/ で shadcn/ui を初期化し、components.json を生成。lib/utils.ts に cn() ヘルパーを作成。レイアウトに必要な shadcn/ui コンポーネント（Button, Sheet, Separator, Sidebar 系）を components/ui/ に追加する",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-schema",
        "description": "apps/content-reviewer/prisma/schema.prisma に全 7 テーブル（users, content_checks, content_segments, check_results, expression_rules, knowledge_articles, knowledge_embeddings）を定義。pgvector 拡張の有効化、全リレーション・インデックス・enum（source, status, check_type, severity, source_type）を含め、prisma generate が成功する状態にする",
        "wave": 2,
        "done": true
      },
      {
        "id": "app-layout-shell",
        "description": "apps/content-reviewer/src/app/layout.tsx にルートレイアウトを実装。shadcn/ui の Sidebar コンポーネントを使ったサイドバー（ナビゲーション: ダッシュボード, チェック実行, 表現ルール, ナレッジ）+ ヘッダー（アプリ名表示）のシェル UI を components/layout/ 配下に作成（sidebar-nav.tsx, header.tsx, app-shell.tsx）し、レスポンシブ対応する",
        "wave": 3,
        "done": true
      },
      {
        "id": "stub-pages",
        "description": "全ルートのスタブページを作成: app/page.tsx（ダッシュボード）、app/login/page.tsx、app/checks/new/page.tsx、app/checks/[id]/page.tsx、app/rules/page.tsx、app/knowledge/page.tsx、app/knowledge/import/page.tsx。各ページはページタイトルのみ表示する Server Component とし、app-shell レイアウトでラップされた状態にする",
        "wave": 3,
        "done": true
      },
      {
        "id": "verify-milestone1",
        "description": "pnpm lint && pnpm typecheck && pnpm build を実行し全て成功することを確認。prisma generate が成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラーがあれば全て修正する",
        "wave": 4,
        "done": true
      }
    ]
  },
  {
    "milestone": 2,
    "goal": "Supabase Auth による Google OAuth ログイン・ログアウトが動作し、未認証時は /login にリダイレクトされ、開発環境（NODE_ENV=development）では認証スキップでダミーユーザーとしてダッシュボード（空の / ページ）にアクセスできる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test",
    "done": true,
    "tasks": [
      {
        "id": "auth-deps-and-test-setup",
        "description": "apps/content-reviewer/package.json に @supabase/supabase-js, @supabase/ssr, vitest を追加し pnpm install を実行。apps/content-reviewer/vitest.config.ts を作成（src/ 配下のテストを対象、パスエイリアス @/ を設定）。apps/content-reviewer/package.json に test script（vitest run）を追加。ルート package.json に test script（pnpm -r run test）を追加",
        "wave": 1,
        "done": true
      },
      {
        "id": "auth-contracts",
        "description": "auth context と shared context の型定義を作成。src/backend/contexts/shared/domain/models/user-id.model.ts（UserId branded type）、src/backend/contexts/shared/domain/models/email.model.ts（Email 値オブジェクト、バリデーション付き）。src/backend/contexts/auth/domain/models/user.model.ts の interface/型定義（id, email, name, avatarUrl, createdAt, updatedAt）。src/backend/contexts/auth/domain/gateways/auth.gateway.ts（AuthGateway interface: getCurrentUser, signInWithGoogle, signOut, onAuthStateChange）。src/backend/contexts/auth/domain/gateways/user.repository.ts（UserRepository interface: findById, findByEmail, upsert）",
        "wave": 1,
        "done": true
      },
      {
        "id": "supabase-client-init",
        "description": "src/backend/contexts/shared/infrastructure/db/supabase-server-client.ts に Next.js Server Component / Server Action 用の Supabase クライアント生成関数を実装（@supabase/ssr の createServerClient + cookies()）。src/backend/contexts/shared/infrastructure/db/supabase-browser-client.ts にブラウザ用の Supabase クライアント生成関数を実装（@supabase/ssr の createBrowserClient）。src/backend/contexts/shared/infrastructure/db/supabase-middleware-client.ts に middleware 用のクライアント生成関数を実装（NextRequest/NextResponse を受け取り cookie を操作）。環境変数型定義を src/lib/env.ts に作成（NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY）",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-domain-models",
        "description": "src/backend/contexts/auth/domain/models/user.model.ts に User Rich Domain Model を実装。ファクトリメソッド create(id, email, name, avatarUrl?) でバリデーション実施（Email 値オブジェクト使用）。fromSupabaseUser(supabaseUser) でSupabase Auth ユーザーからの変換。ダミーユーザー生成用の createDummy() static メソッド（開発環境スキップ用、固定 UUID + dummy@example.com）。src/backend/contexts/shared/domain/models/ の UserId, Email 値オブジェクトの実装（ファクトリメソッド + バリデーション）",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-domain-tests",
        "description": "src/backend/contexts/auth/domain/models/__tests__/user.model.test.ts に User モデルのユニットテスト（create 正常系、バリデーションエラー、createDummy、fromSupabaseUser）。src/backend/contexts/shared/domain/models/__tests__/email.model.test.ts に Email 値オブジェクトのテスト。src/backend/contexts/shared/domain/models/__tests__/user-id.model.test.ts に UserId のテスト。vitest で全テスト pass することを確認",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-backend-layers",
        "description": "auth context の infrastructure〜presentation 全層を実装。src/backend/contexts/auth/infrastructure/supabase-auth.gateway.ts（AuthGateway の Supabase 実装: getCurrentUser でセッション取得 → User モデル変換、signInWithGoogle で OAuth リダイレクト URL 生成、signOut）。src/backend/contexts/auth/infrastructure/repositories/prisma-user.repository.ts（UserRepository の Prisma 実装: findById, findByEmail, upsert で Prisma User ↔ ドメイン User 変換）。src/backend/contexts/auth/application/usecases/get-current-user.usecase.ts, sign-in.usecase.ts, sign-out.usecase.ts, sync-user.usecase.ts（ログイン後に Supabase auth.users → アプリ users テーブルに同期）。src/backend/contexts/auth/presentation/composition/auth.composition.ts, actions/sign-in.action.ts, actions/sign-out.action.ts, loaders/current-user.loader.ts",
        "wave": 3,
        "done": true
      },
      {
        "id": "auth-middleware-and-callback",
        "description": "apps/content-reviewer/src/middleware.ts を作成。supabase-middleware-client でセッションを検証し、未認証時は /login にリダイレクト。/login, /auth/callback, _next/static, _next/image, favicon.ico はスキップ。NODE_ENV=development 時は認証チェックをスキップしダミーユーザーとして通過。src/app/auth/callback/route.ts を作成（Supabase SSR の code exchange: URL パラメータの code を exchangeCodeForSession で処理し / にリダイレクト）",
        "wave": 3,
        "done": true
      },
      {
        "id": "login-page-ui",
        "description": "src/app/login/page.tsx を更新し、Google OAuth ログインボタン（shadcn/ui Button）を配置。sign-in.action.ts の Server Action を呼び出して Supabase Auth の Google OAuth フローを開始。ログイン成功後のリダイレクト処理。(app)/layout.tsx にログアウトボタンを追加（ヘッダー右側にユーザー名表示 + ログアウトボタン、current-user.loader.ts でユーザー情報取得、sign-out.action.ts でログアウト実行）",
        "wave": 3,
        "done": true
      },
      {
        "id": "fix-dev-mode-dummy-user",
        "description": "開発環境（NODE_ENV=development）で / にアクセスすると Missing environment variable: NEXT_PUBLIC_SUPABASE_URL エラーが発生する。原因: (app)/layout.tsx が loadCurrentUser() → createGetCurrentUserUseCase() → createSupabaseServerClient() を呼び出し、Supabase 環境変数が未設定のためクラッシュする。修正方針: current-user.loader.ts の loadCurrentUser() 先頭で NODE_ENV === 'development' を判定し、User.createDummy() を返すことで Supabase 接続をバイパスする。同様に sign-in.action.ts と sign-out.action.ts にも開発環境ガードを追加する（開発環境ではリダイレクトのみ）",
        "wave": 5,
        "done": true
      },
      {
        "id": "verify-milestone2",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test を実行し全て成功することを確認。開発環境（NODE_ENV=development）で認証スキップが動作し / にアクセスできることを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗があれば全て修正する",
        "wave": 6,
        "done": true
      }
    ]
  },
  {
    "milestone": 3,
    "goal": "/rules ページで表現ルール（NG表現→推奨表現）の一覧表示・新規登録・編集・削除ができ、ExpressionRule ドメインモデル → PrismaExpressionRuleRepository → UseCase（CRUD 4種） → Server Actions → UI の全レイヤーが縦に通って DB に永続化される",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": true,
    "tasks": [
      {
        "id": "expression-rule-contracts",
        "description": "expression-rule context の契約定義。src/backend/contexts/shared/domain/models/expression-rule-id.model.ts に ExpressionRuleId branded type（createExpressionRuleId ファクトリ + UUID バリデーション）を作成。src/backend/contexts/expression-rule/domain/models/expression-rule.model.ts に ExpressionRule クラスの型定義（ExpressionRuleProps interface: id, ngExpression, recommendedExpression, description, isActive, createdBy, createdAt, updatedAt）と Result 型を定義。src/backend/contexts/expression-rule/domain/gateways/expression-rule.repository.ts に ExpressionRuleRepository interface（save, findById, findAll, findActive, delete）をドメインモデル型のみで定義",
        "wave": 1,
        "done": true
      },
      {
        "id": "expression-rule-domain-model",
        "description": "src/backend/contexts/expression-rule/domain/models/expression-rule.model.ts に ExpressionRule Rich Domain Model を実装。private constructor + ファクトリメソッド create(ngExpression, recommendedExpression, description?, createdBy) で NG表現・推奨表現の空文字バリデーション。reconstruct() で DB からの復元。update(ngExpression, recommendedExpression, description?) で更新。deactivate()/activate() で有効化/無効化。src/backend/contexts/shared/domain/models/__tests__/expression-rule-id.model.test.ts と src/backend/contexts/expression-rule/domain/models/__tests__/expression-rule.model.test.ts にユニットテスト（create 正常系、バリデーションエラー、update、deactivate/activate）",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-repository-impl",
        "description": "src/backend/contexts/expression-rule/infrastructure/repositories/prisma-expression-rule.repository.ts に PrismaExpressionRuleRepository を実装。ExpressionRuleRepository interface を implements し、Prisma ExpressionRule ↔ ドメイン ExpressionRule 変換（toDomain / toPrisma private メソッド）を行う。save（upsert）、findById、findAll、findActive（isActive=true のみ）、delete を実装。prisma-client.ts の共有 PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-usecases",
        "description": "expression-rule context の UseCase 4種を実装。src/backend/contexts/expression-rule/application/usecases/create-expression-rule.usecase.ts（ExpressionRuleRepository を DI、ExpressionRule.create → repository.save）、update-expression-rule.usecase.ts（findById → update → save、存在しない場合は throw）、delete-expression-rule.usecase.ts（findById → repository.delete、存在しない場合は throw）、list-expression-rules.usecase.ts（repository.findAll で一覧取得）。各 UseCase はクラスベース + constructor DI + execute() メソッド",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-usecase-tests",
        "description": "UseCase 4種のユニットテストを作成。src/backend/contexts/expression-rule/application/usecases/__tests__/create-expression-rule.usecase.test.ts、update-expression-rule.usecase.test.ts、delete-expression-rule.usecase.test.ts、list-expression-rules.usecase.test.ts。ExpressionRuleRepository をモックし、正常系・異常系（バリデーションエラー、存在しないルールの更新/削除）をテスト。vitest で全テスト pass を確認",
        "wave": 2,
        "done": true
      },
      {
        "id": "playwright-setup",
        "description": "apps/content-reviewer/package.json に @playwright/test を devDependencies に追加し pnpm install を実行。apps/content-reviewer/playwright.config.ts を作成（baseURL: http://localhost:3000、webServer で next dev 起動、テストディレクトリ: e2e/）。apps/content-reviewer/e2e/rules.spec.ts に /rules ページの E2E テストを作成（ルール一覧表示、新規登録フォーム表示、登録→一覧に表示、編集、削除の基本シナリオ）。ルート package.json の scripts に e2e script を追加",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-presentation",
        "description": "expression-rule context の presentation 層を実装。src/backend/contexts/expression-rule/presentation/composition/expression-rule.composition.ts に createListExpressionRulesUseCase / createCreateExpressionRuleUseCase / createUpdateExpressionRuleUseCase / createDeleteExpressionRuleUseCase ファクトリ関数（PrismaExpressionRuleRepository + prisma を注入）。src/backend/contexts/expression-rule/presentation/loaders/expression-rules.loader.ts に loadExpressionRules()（UseCase 経由で一覧取得）。src/backend/contexts/expression-rule/presentation/actions/create-expression-rule.action.ts、update-expression-rule.action.ts、delete-expression-rule.action.ts に 'use server' Server Actions（FormData → UseCase 呼び出し → revalidatePath('/rules')）。開発環境ではダミーユーザー ID を使用",
        "wave": 3,
        "done": true
      },
      {
        "id": "expression-rule-ui",
        "description": "shadcn/ui コンポーネント追加（Dialog, Table, Label, Textarea, Badge が未追加なら追加）。src/components/rules/expression-rule-table.tsx（'use client'、一覧テーブル: NG表現・推奨表現・補足説明・ステータス・操作ボタン）、expression-rule-form-dialog.tsx（'use client'、新規登録/編集兼用の Dialog フォーム: ngExpression, recommendedExpression, description 入力 → Server Action 呼び出し）、delete-expression-rule-button.tsx（'use client'、削除確認付きボタン → Server Action 呼び出し）を作成。src/app/(app)/rules/page.tsx を更新し、loadExpressionRules() で一覧取得 → ExpressionRuleTable に props 渡し + 新規登録ボタン配置",
        "wave": 3,
        "done": true
      },
      {
        "id": "verify-milestone3",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test を実行し全て成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗・E2E テスト失敗があれば全て修正する",
        "wave": 4,
        "done": true
      },
      {
        "id": "fix-create-usecase-test-type-error",
        "description": "typecheck エラーの修正。原因: test/unit/contexts/expression-rule/application/usecases/create-expression-rule.usecase.test.ts が CreateExpressionRuleInput に 'id' フィールドを渡しているが、最終的な UseCase 実装（UUID自動生成方式）では 'id' が input に含まれない。コンフリクト解決の結果 expression-rule-usecase-tests ブランチの実装（UUID自動生成）を採用したが、expression-rule-usecases ブランチのテストファイル（test/unit/ 配下）が古い設計のままになっている。修正方針: test/unit/.../ create-expression-rule.usecase.test.ts の各 execute() 呼び出しから 'id' フィールドを削除し、result.id のアサーションは UUID 形式（expect(result.id).toMatch(/^[0-9a-f-]{36}$/)）に変更する",
        "wave": 5,
        "done": true
      }
    ]
  },
  {
    "milestone": 4,
    "goal": "/knowledge ページでナレッジ記事の一覧表示・手動登録・編集ができ、保存時に OpenAI Embeddings API で Embedding が自動生成されて pgvector に格納され、KnowledgeArticle / KnowledgeEmbedding ドメインモデル → Repository → UseCase → UI が動作する",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": [
      {
        "id": "knowledge-contracts",
        "description": "knowledge context の契約定義。src/backend/contexts/shared/domain/models/knowledge-article-id.model.ts（KnowledgeArticleId branded type + UUID バリデーション）、knowledge-embedding-id.model.ts（KnowledgeEmbeddingId branded type）を作成。src/backend/contexts/shared/domain/gateways/embedding.gateway.ts に EmbeddingGateway interface（generateEmbedding(text: string): Promise<number[]>）を定義。src/backend/contexts/knowledge/domain/models/knowledge-article.model.ts に KnowledgeArticleProps interface と Result 型の型定義のみを記述。src/backend/contexts/knowledge/domain/models/knowledge-embedding.model.ts に KnowledgeEmbeddingProps interface と型定義のみを記述。src/backend/contexts/knowledge/domain/gateways/knowledge-article.repository.ts に KnowledgeArticleRepository interface（save, findById, findAll, delete）を定義。src/backend/contexts/knowledge/domain/gateways/knowledge-embedding.repository.ts に KnowledgeEmbeddingRepository interface（saveMany, deleteByArticleId, searchSimilar）を定義",
        "wave": 1,
        "done": true
      },
      {
        "id": "knowledge-article-domain-model",
        "description": "src/backend/contexts/knowledge/domain/models/knowledge-article.model.ts に KnowledgeArticle Rich Domain Model を実装。private constructor + ファクトリメソッド create(title, content, sourceType, createdBy, sourceUrl?) でタイトル・本文の空文字バリデーション（Result 型で返す）。reconstruct() で DB からの復元。update(title, content) で更新。src/backend/contexts/knowledge/domain/models/__tests__/knowledge-article.model.test.ts にユニットテスト（create 正常系、バリデーションエラー、update）",
        "wave": 2,
        "done": true
      },
      {
        "id": "knowledge-embedding-domain-model",
        "description": "src/backend/contexts/knowledge/domain/models/knowledge-embedding.model.ts に KnowledgeEmbedding Rich Domain Model を実装。private constructor + ファクトリメソッド create(articleId, chunkIndex, chunkText, embedding) で embedding の次元数（1536）バリデーション（Result 型で返す）。reconstruct() で DB からの復元。src/backend/contexts/knowledge/domain/models/__tests__/knowledge-embedding.model.test.ts にユニットテスト（create 正常系、次元数バリデーションエラー）",
        "wave": 2,
        "done": true
      },
      {
        "id": "openai-embedding-gateway",
        "description": "apps/content-reviewer/package.json に openai パッケージを追加し pnpm install を実行。src/backend/contexts/shared/infrastructure/ai/openai-embedding.gateway.ts に EmbeddingGateway を implements した OpenAIEmbeddingGateway クラスを実装（openai SDK の embeddings.create を呼び出し、model: 'text-embedding-3-small'、1536次元のベクトルを返す）。環境変数 OPENAI_API_KEY を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-knowledge-article-repository",
        "description": "src/backend/contexts/knowledge/infrastructure/repositories/prisma-knowledge-article.repository.ts に PrismaKnowledgeArticleRepository を実装。KnowledgeArticleRepository interface を implements し、Prisma KnowledgeArticle ↔ ドメイン KnowledgeArticle 変換（toDomain / toPrisma private メソッド）。save（upsert）、findById、findAll、delete を実装。共有 prisma-client.ts の PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-knowledge-embedding-repository",
        "description": "src/backend/contexts/knowledge/infrastructure/repositories/prisma-knowledge-embedding.repository.ts に PrismaKnowledgeEmbeddingRepository を実装。KnowledgeEmbeddingRepository interface を implements し、saveMany（createMany）、deleteByArticleId、searchSimilar（pgvector の <-> 演算子を使ったコサイン距離検索、$queryRaw で実行）を実装。共有 prisma-client.ts の PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "knowledge-usecases",
        "description": "knowledge context の UseCase 3種を実装。src/backend/contexts/knowledge/application/usecases/create-knowledge-article.usecase.ts（KnowledgeArticleRepository + KnowledgeEmbeddingRepository + EmbeddingGateway を DI。KnowledgeArticle.create → repository.save → EmbeddingGateway.generateEmbedding でチャンク分割なし全文 Embedding → KnowledgeEmbedding.create → embeddingRepository.saveMany）。update-knowledge-article.usecase.ts（findById → update → save → deleteByArticleId → 再 Embedding 生成 → saveMany）。list-knowledge-articles.usecase.ts（repository.findAll）。delete-knowledge-article.usecase.ts（findById → embeddingRepository.deleteByArticleId → repository.delete）。各 UseCase はクラスベース + constructor DI + execute() メソッド",
        "wave": 3,
        "done": true
      },
      {
        "id": "knowledge-usecase-tests",
        "description": "UseCase 4種のユニットテストを作成。src/backend/contexts/knowledge/application/usecases/__tests__/create-knowledge-article.usecase.test.ts（KnowledgeArticleRepository・KnowledgeEmbeddingRepository・EmbeddingGateway をモック、正常系: EmbeddingGateway.generateEmbedding が呼ばれ embeddingRepository.saveMany も呼ばれることを検証）。update-knowledge-article.usecase.test.ts（記事更新 + Embedding 再生成の検証）。list-knowledge-articles.usecase.test.ts。delete-knowledge-article.usecase.test.ts（deleteByArticleId → delete の順序検証）。vitest で全テスト pass を確認",
        "wave": 3,
        "done": true
      },
      {
        "id": "knowledge-presentation",
        "description": "knowledge context の presentation 層を実装。src/backend/contexts/knowledge/presentation/composition/knowledge-article.composition.ts に createListKnowledgeArticlesUseCase / createCreateKnowledgeArticleUseCase / createUpdateKnowledgeArticleUseCase / createDeleteKnowledgeArticleUseCase ファクトリ関数（PrismaKnowledgeArticleRepository + PrismaKnowledgeEmbeddingRepository + OpenAIEmbeddingGateway + prisma を注入）。src/backend/contexts/knowledge/presentation/loaders/knowledge-articles.loader.ts に loadKnowledgeArticles()（UseCase 経由で一覧取得）。src/backend/contexts/knowledge/presentation/actions/create-knowledge-article.action.ts、update-knowledge-article.action.ts、delete-knowledge-article.action.ts に 'use server' Server Actions（FormData → UseCase 呼び出し → revalidatePath('/knowledge')）。開発環境ではダミーユーザー ID を使用",
        "wave": 4,
        "done": false
      },
      {
        "id": "knowledge-ui",
        "description": "shadcn/ui コンポーネント追加（Textarea, ScrollArea 等が未追加なら追加）。src/components/knowledge/knowledge-article-table.tsx（'use client'、一覧テーブル: タイトル・ソース種別・作成日・操作ボタン）、knowledge-article-form-dialog.tsx（'use client'、新規登録/編集兼用の Dialog フォーム: title, content, sourceUrl 入力 → Server Action 呼び出し）、delete-knowledge-article-button.tsx（'use client'、削除確認付きボタン → Server Action 呼び出し）を作成。src/app/(app)/knowledge/page.tsx を更新し、loadKnowledgeArticles() で一覧取得 → KnowledgeArticleTable に props 渡し + 新規登録ボタン配置。e2e/knowledge.spec.ts に /knowledge ページの E2E テスト（一覧表示・新規登録→一覧反映・編集・削除の基本シナリオ）を追加",
        "wave": 5,
        "done": false
      },
      {
        "id": "verify-milestone4",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test を実行し全て成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗・E2E テスト失敗があれば全て修正する",
        "wave": 6,
        "done": false
      },
      {
        "id": "fix-e2e-next-build-conflict",
        "description": "E2E テストが Runtime Error で失敗する問題を修正する。原因: pnpm build（本番ビルド）実行後に pnpm e2e を実行すると playwright.config.ts の webServer.command である pnpm dev が .next/ ディレクトリの不完全な状態で起動し、'ENOENT: no such file or directory, open .../.next/server/pages/_document.js' エラーが発生してページが表示されない。修正方針: playwright.config.ts の webServer.command を 'pnpm dev' から '.next/ を削除してから pnpm dev を起動するコマンド' に変更するか、または pnpm verify の e2e 実行前に .next/ をクリアするステップを追加する（例: 'rm -rf .next && pnpm dev'）。あるいは webServer を 'next build && next start' に変更して本番ビルドのサーバーで E2E を実行することも検討する",
        "wave": 7,
        "done": false
      },
      {
        "id": "fix-knowledge-embedding-repository-test-dimensions",
        "description": "prisma-knowledge-embedding.repository.test.ts の sampleEmbeddingValues が Array.from({ length: 3 }, ...) で3次元になっており、KnowledgeEmbedding.create() の1536次元バリデーションで失敗している。修正方針: sampleEmbeddingValues を Array.from({ length: 1536 }, (_, i) => (i + 1) * 0.001) に変更する。また searchSimilar テストの rawRows.embedding も '[0.1,0.2,...（1536次元分）]' に更新する（reconstruct はバリデーションなしなので現状は通るが、正しいテストデータにする）",
        "wave": 8,
        "done": true
      },
      {
        "id": "fix-e2e-database-url-missing",
        "description": "E2E テストが DATABASE_URL 未設定環境でクラッシュする問題を修正する。原因: pnpm e2e 実行時に playwright.config.ts の webServer.command である pnpm dev が起動し、/rules ページアクセス時に PrismaExpressionRuleRepository.findAll() が 'Environment variable not found: DATABASE_URL' エラーをスローしてページが表示されない（PrismaClientInitializationError）。結果として E2E テストが全てタイムアウトで失敗する。修正方針: rules/page.tsx と knowledge/page.tsx のローダー呼び出し部分、または各 Repository 実装に DATABASE_URL 未設定時のガード（開発環境ではモックデータを返す）を追加する。あるいは E2E テスト用の .env.test ファイルに SQLite や in-memory DB を設定し、テスト環境で DB なしでも動作するようにする。最も簡単な方法は presentation/loaders に開発環境ガードを追加してモックデータを返すことだが、長期的には DATABASE_URL をローカル開発 .env.local に設定することが推奨される",
        "wave": 9,
        "done": false
      }
    ]
  },
  {
    "milestone": 5,
    "goal": "/knowledge/import で note アカウント名を入力すると NoteScraperGateway 経由で記事一覧が表示され、選択した記事の本文を取得して DB に保存し Embedding を生成できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": []
  },
  {
    "milestone": 6,
    "goal": "/checks/new でテキストを入力して送信すると、AIGateway による段落分割→5種のチェック（ファクトチェック・ナレッジ整合性・表現ルール適合・炎上リスク・文章クオリティ）が並列実行され、SSE で進捗がリアルタイム表示され、完了後 /checks/[id] で結果詳細（セグメントごとの指摘・severity・修正提案）を確認できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": []
  },
  {
    "milestone": 7,
    "goal": "ダッシュボード（/）に過去のチェック履歴一覧が表示され、ソース種別（Web / Slack）・ステータス・実行日時でフィルタリングでき、各行クリックで /checks/[id] の詳細ページに遷移できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": []
  },
  {
    "milestone": 8,
    "goal": "/api/slack/events で Slack Events API の Webhook を受信し、Slack 署名検証・url_verification 対応の上、@sns-checker メンション時に waitUntil でバックグラウンドチェックを実行し、完了後にスレッドへ結果サマリーと /checks/[id] のパーマリンクを返信できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test",
    "done": false,
    "tasks": []
  }
]

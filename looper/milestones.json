[{
    "milestone": 1,
    "goal": "pnpm workspace + Next.js App Router プロジェクトが起動し、Biome lint / typecheck / build が通り、shadcn/ui + Tailwind CSS でレイアウト（サイドバー + ヘッダー）が表示され、Prisma スキーマに全テーブルが定義されて prisma generate が成功する",
    "verification": "pnpm lint && pnpm typecheck && pnpm build",
    "done": true,
    "tasks": [{
        "id": "project-scaffold",
        "description": "pnpm workspace + Next.js App Router プロジェクトの初期構築。ルート package.json（workspace scripts: lint, typecheck, build）、pnpm-workspace.yaml、apps/content-reviewer/ 配下に package.json・next.config.ts・tsconfig.json・tailwind.config.ts・postcss.config.mjs・biome.json を作成し、Tailwind CSS v4 + PostCSS を設定、apps/content-reviewer/src/app/globals.css に Tailwind ディレクティブを記述、最小限の app/layout.tsx と app/page.tsx で pnpm build が通る状態にする",
        "wave": 1,
        "done": true
      },
      {
        "id": "shadcn-ui-setup",
        "description": "apps/content-reviewer/ で shadcn/ui を初期化し、components.json を生成。lib/utils.ts に cn() ヘルパーを作成。レイアウトに必要な shadcn/ui コンポーネント（Button, Sheet, Separator, Sidebar 系）を components/ui/ に追加する",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-schema",
        "description": "apps/content-reviewer/prisma/schema.prisma に全 7 テーブル（users, content_checks, content_segments, check_results, expression_rules, knowledge_articles, knowledge_embeddings）を定義。pgvector 拡張の有効化、全リレーション・インデックス・enum（source, status, check_type, severity, source_type）を含め、prisma generate が成功する状態にする",
        "wave": 2,
        "done": true
      },
      {
        "id": "app-layout-shell",
        "description": "apps/content-reviewer/src/app/layout.tsx にルートレイアウトを実装。shadcn/ui の Sidebar コンポーネントを使ったサイドバー（ナビゲーション: ダッシュボード, チェック実行, 表現ルール, ナレッジ）+ ヘッダー（アプリ名表示）のシェル UI を components/layout/ 配下に作成（sidebar-nav.tsx, header.tsx, app-shell.tsx）し、レスポンシブ対応する",
        "wave": 3,
        "done": true
      },
      {
        "id": "stub-pages",
        "description": "全ルートのスタブページを作成: app/page.tsx（ダッシュボード）、app/login/page.tsx、app/checks/new/page.tsx、app/checks/[id]/page.tsx、app/rules/page.tsx、app/knowledge/page.tsx、app/knowledge/import/page.tsx。各ページはページタイトルのみ表示する Server Component とし、app-shell レイアウトでラップされた状態にする",
        "wave": 3,
        "done": true
      },
      {
        "id": "verify-milestone1",
        "description": "pnpm lint && pnpm typecheck && pnpm build を実行し全て成功することを確認。prisma generate が成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラーがあれば全て修正する",
        "wave": 4,
        "done": true
      }
    ]
  },
  {
    "milestone": 2,
    "goal": "Supabase Auth による Google OAuth ログイン・ログアウトが動作し、未認証時は /login にリダイレクトされ、開発環境（NODE_ENV=development）では認証スキップでダミーユーザーとしてダッシュボード（空の / ページ）にアクセスできる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test",
    "done": true,
    "tasks": [{
        "id": "auth-deps-and-test-setup",
        "description": "apps/content-reviewer/package.json に @supabase/supabase-js, @supabase/ssr, vitest を追加し pnpm install を実行。apps/content-reviewer/vitest.config.ts を作成（src/ 配下のテストを対象、パスエイリアス @/ を設定）。apps/content-reviewer/package.json に test script（vitest run）を追加。ルート package.json に test script（pnpm -r run test）を追加",
        "wave": 1,
        "done": true
      },
      {
        "id": "auth-contracts",
        "description": "auth context と shared context の型定義を作成。src/backend/contexts/shared/domain/models/user-id.model.ts（UserId branded type）、src/backend/contexts/shared/domain/models/email.model.ts（Email 値オブジェクト、バリデーション付き）。src/backend/contexts/auth/domain/models/user.model.ts の interface/型定義（id, email, name, avatarUrl, createdAt, updatedAt）。src/backend/contexts/auth/domain/gateways/auth.gateway.ts（AuthGateway interface: getCurrentUser, signInWithGoogle, signOut, onAuthStateChange）。src/backend/contexts/auth/domain/gateways/user.repository.ts（UserRepository interface: findById, findByEmail, upsert）",
        "wave": 1,
        "done": true
      },
      {
        "id": "supabase-client-init",
        "description": "src/backend/contexts/shared/infrastructure/db/supabase-server-client.ts に Next.js Server Component / Server Action 用の Supabase クライアント生成関数を実装（@supabase/ssr の createServerClient + cookies()）。src/backend/contexts/shared/infrastructure/db/supabase-browser-client.ts にブラウザ用の Supabase クライアント生成関数を実装（@supabase/ssr の createBrowserClient）。src/backend/contexts/shared/infrastructure/db/supabase-middleware-client.ts に middleware 用のクライアント生成関数を実装（NextRequest/NextResponse を受け取り cookie を操作）。環境変数型定義を src/lib/env.ts に作成（NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY）",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-domain-models",
        "description": "src/backend/contexts/auth/domain/models/user.model.ts に User Rich Domain Model を実装。ファクトリメソッド create(id, email, name, avatarUrl?) でバリデーション実施（Email 値オブジェクト使用）。fromSupabaseUser(supabaseUser) でSupabase Auth ユーザーからの変換。ダミーユーザー生成用の createDummy() static メソッド（開発環境スキップ用、固定 UUID + dummy@example.com）。src/backend/contexts/shared/domain/models/ の UserId, Email 値オブジェクトの実装（ファクトリメソッド + バリデーション）",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-domain-tests",
        "description": "src/backend/contexts/auth/domain/models/__tests__/user.model.test.ts に User モデルのユニットテスト（create 正常系、バリデーションエラー、createDummy、fromSupabaseUser）。src/backend/contexts/shared/domain/models/__tests__/email.model.test.ts に Email 値オブジェクトのテスト。src/backend/contexts/shared/domain/models/__tests__/user-id.model.test.ts に UserId のテスト。vitest で全テスト pass することを確認",
        "wave": 2,
        "done": true
      },
      {
        "id": "auth-backend-layers",
        "description": "auth context の infrastructure〜presentation 全層を実装。src/backend/contexts/auth/infrastructure/supabase-auth.gateway.ts（AuthGateway の Supabase 実装: getCurrentUser でセッション取得 → User モデル変換、signInWithGoogle で OAuth リダイレクト URL 生成、signOut）。src/backend/contexts/auth/infrastructure/repositories/prisma-user.repository.ts（UserRepository の Prisma 実装: findById, findByEmail, upsert で Prisma User ↔ ドメイン User 変換）。src/backend/contexts/auth/application/usecases/get-current-user.usecase.ts, sign-in.usecase.ts, sign-out.usecase.ts, sync-user.usecase.ts（ログイン後に Supabase auth.users → アプリ users テーブルに同期）。src/backend/contexts/auth/presentation/composition/auth.composition.ts, actions/sign-in.action.ts, actions/sign-out.action.ts, loaders/current-user.loader.ts",
        "wave": 3,
        "done": true
      },
      {
        "id": "auth-middleware-and-callback",
        "description": "apps/content-reviewer/src/middleware.ts を作成。supabase-middleware-client でセッションを検証し、未認証時は /login にリダイレクト。/login, /auth/callback, _next/static, _next/image, favicon.ico はスキップ。NODE_ENV=development 時は認証チェックをスキップしダミーユーザーとして通過。src/app/auth/callback/route.ts を作成（Supabase SSR の code exchange: URL パラメータの code を exchangeCodeForSession で処理し / にリダイレクト）",
        "wave": 3,
        "done": true
      },
      {
        "id": "login-page-ui",
        "description": "src/app/login/page.tsx を更新し、Google OAuth ログインボタン（shadcn/ui Button）を配置。sign-in.action.ts の Server Action を呼び出して Supabase Auth の Google OAuth フローを開始。ログイン成功後のリダイレクト処理。(app)/layout.tsx にログアウトボタンを追加（ヘッダー右側にユーザー名表示 + ログアウトボタン、current-user.loader.ts でユーザー情報取得、sign-out.action.ts でログアウト実行）",
        "wave": 3,
        "done": true
      },
      {
        "id": "fix-dev-mode-dummy-user",
        "description": "開発環境（NODE_ENV=development）で / にアクセスすると Missing environment variable: NEXT_PUBLIC_SUPABASE_URL エラーが発生する。原因: (app)/layout.tsx が loadCurrentUser() → createGetCurrentUserUseCase() → createSupabaseServerClient() を呼び出し、Supabase 環境変数が未設定のためクラッシュする。修正方針: current-user.loader.ts の loadCurrentUser() 先頭で NODE_ENV === 'development' を判定し、User.createDummy() を返すことで Supabase 接続をバイパスする。同様に sign-in.action.ts と sign-out.action.ts にも開発環境ガードを追加する（開発環境ではリダイレクトのみ）",
        "wave": 5,
        "done": true
      },
      {
        "id": "verify-milestone2",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test を実行し全て成功することを確認。開発環境（NODE_ENV=development）で認証スキップが動作し / にアクセスできることを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗があれば全て修正する",
        "wave": 6,
        "done": true
      }
    ]
  },
  {
    "milestone": 3,
    "goal": "/rules ページで表現ルール（NG表現→推奨表現）の一覧表示・新規登録・編集・削除ができ、ExpressionRule ドメインモデル → PrismaExpressionRuleRepository → UseCase（CRUD 4種） → Server Actions → UI の全レイヤーが縦に通って DB に永続化される",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": true,
    "tasks": [{
        "id": "expression-rule-contracts",
        "description": "expression-rule context の契約定義。src/backend/contexts/shared/domain/models/expression-rule-id.model.ts に ExpressionRuleId branded type（createExpressionRuleId ファクトリ + UUID バリデーション）を作成。src/backend/contexts/expression-rule/domain/models/expression-rule.model.ts に ExpressionRule クラスの型定義（ExpressionRuleProps interface: id, ngExpression, recommendedExpression, description, isActive, createdBy, createdAt, updatedAt）と Result 型を定義。src/backend/contexts/expression-rule/domain/gateways/expression-rule.repository.ts に ExpressionRuleRepository interface（save, findById, findAll, findActive, delete）をドメインモデル型のみで定義",
        "wave": 1,
        "done": true
      },
      {
        "id": "expression-rule-domain-model",
        "description": "src/backend/contexts/expression-rule/domain/models/expression-rule.model.ts に ExpressionRule Rich Domain Model を実装。private constructor + ファクトリメソッド create(ngExpression, recommendedExpression, description?, createdBy) で NG表現・推奨表現の空文字バリデーション。reconstruct() で DB からの復元。update(ngExpression, recommendedExpression, description?) で更新。deactivate()/activate() で有効化/無効化。src/backend/contexts/shared/domain/models/__tests__/expression-rule-id.model.test.ts と src/backend/contexts/expression-rule/domain/models/__tests__/expression-rule.model.test.ts にユニットテスト（create 正常系、バリデーションエラー、update、deactivate/activate）",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-repository-impl",
        "description": "src/backend/contexts/expression-rule/infrastructure/repositories/prisma-expression-rule.repository.ts に PrismaExpressionRuleRepository を実装。ExpressionRuleRepository interface を implements し、Prisma ExpressionRule ↔ ドメイン ExpressionRule 変換（toDomain / toPrisma private メソッド）を行う。save（upsert）、findById、findAll、findActive（isActive=true のみ）、delete を実装。prisma-client.ts の共有 PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-usecases",
        "description": "expression-rule context の UseCase 4種を実装。src/backend/contexts/expression-rule/application/usecases/create-expression-rule.usecase.ts（ExpressionRuleRepository を DI、ExpressionRule.create → repository.save）、update-expression-rule.usecase.ts（findById → update → save、存在しない場合は throw）、delete-expression-rule.usecase.ts（findById → repository.delete、存在しない場合は throw）、list-expression-rules.usecase.ts（repository.findAll で一覧取得）。各 UseCase はクラスベース + constructor DI + execute() メソッド",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-usecase-tests",
        "description": "UseCase 4種のユニットテストを作成。src/backend/contexts/expression-rule/application/usecases/__tests__/create-expression-rule.usecase.test.ts、update-expression-rule.usecase.test.ts、delete-expression-rule.usecase.test.ts、list-expression-rules.usecase.test.ts。ExpressionRuleRepository をモックし、正常系・異常系（バリデーションエラー、存在しないルールの更新/削除）をテスト。vitest で全テスト pass を確認",
        "wave": 2,
        "done": true
      },
      {
        "id": "playwright-setup",
        "description": "apps/content-reviewer/package.json に @playwright/test を devDependencies に追加し pnpm install を実行。apps/content-reviewer/playwright.config.ts を作成（baseURL: http://localhost:3000、webServer で next dev 起動、テストディレクトリ: e2e/）。apps/content-reviewer/e2e/rules.spec.ts に /rules ページの E2E テストを作成（ルール一覧表示、新規登録フォーム表示、登録→一覧に表示、編集、削除の基本シナリオ）。ルート package.json の scripts に e2e script を追加",
        "wave": 2,
        "done": true
      },
      {
        "id": "expression-rule-presentation",
        "description": "expression-rule context の presentation 層を実装。src/backend/contexts/expression-rule/presentation/composition/expression-rule.composition.ts に createListExpressionRulesUseCase / createCreateExpressionRuleUseCase / createUpdateExpressionRuleUseCase / createDeleteExpressionRuleUseCase ファクトリ関数（PrismaExpressionRuleRepository + prisma を注入）。src/backend/contexts/expression-rule/presentation/loaders/expression-rules.loader.ts に loadExpressionRules()（UseCase 経由で一覧取得）。src/backend/contexts/expression-rule/presentation/actions/create-expression-rule.action.ts、update-expression-rule.action.ts、delete-expression-rule.action.ts に 'use server' Server Actions（FormData → UseCase 呼び出し → revalidatePath('/rules')）。開発環境ではダミーユーザー ID を使用",
        "wave": 3,
        "done": true
      },
      {
        "id": "expression-rule-ui",
        "description": "shadcn/ui コンポーネント追加（Dialog, Table, Label, Textarea, Badge が未追加なら追加）。src/components/rules/expression-rule-table.tsx（'use client'、一覧テーブル: NG表現・推奨表現・補足説明・ステータス・操作ボタン）、expression-rule-form-dialog.tsx（'use client'、新規登録/編集兼用の Dialog フォーム: ngExpression, recommendedExpression, description 入力 → Server Action 呼び出し）、delete-expression-rule-button.tsx（'use client'、削除確認付きボタン → Server Action 呼び出し）を作成。src/app/(app)/rules/page.tsx を更新し、loadExpressionRules() で一覧取得 → ExpressionRuleTable に props 渡し + 新規登録ボタン配置",
        "wave": 3,
        "done": true
      },
      {
        "id": "verify-milestone3",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test を実行し全て成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗・E2E テスト失敗があれば全て修正する",
        "wave": 4,
        "done": true
      },
      {
        "id": "fix-create-usecase-test-type-error",
        "description": "typecheck エラーの修正。原因: test/unit/contexts/expression-rule/application/usecases/create-expression-rule.usecase.test.ts が CreateExpressionRuleInput に 'id' フィールドを渡しているが、最終的な UseCase 実装（UUID自動生成方式）では 'id' が input に含まれない。コンフリクト解決の結果 expression-rule-usecase-tests ブランチの実装（UUID自動生成）を採用したが、expression-rule-usecases ブランチのテストファイル（test/unit/ 配下）が古い設計のままになっている。修正方針: test/unit/.../ create-expression-rule.usecase.test.ts の各 execute() 呼び出しから 'id' フィールドを削除し、result.id のアサーションは UUID 形式（expect(result.id).toMatch(/^[0-9a-f-]{36}$/)）に変更する",
        "wave": 5,
        "done": true
      }
    ]
  },
  {
    "milestone": 4,
    "goal": "/knowledge ページでナレッジ記事の一覧表示・手動登録・編集ができ、保存時に OpenAI Embeddings API で Embedding が自動生成されて pgvector に格納され、KnowledgeArticle / KnowledgeEmbedding ドメインモデル → Repository → UseCase → UI が動作する",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": true,
    "tasks": [{
        "id": "knowledge-contracts",
        "description": "knowledge context の契約定義。src/backend/contexts/shared/domain/models/knowledge-article-id.model.ts（KnowledgeArticleId branded type + UUID バリデーション）、knowledge-embedding-id.model.ts（KnowledgeEmbeddingId branded type）を作成。src/backend/contexts/shared/domain/gateways/embedding.gateway.ts に EmbeddingGateway interface（generateEmbedding(text: string): Promise<number[]>）を定義。src/backend/contexts/knowledge/domain/models/knowledge-article.model.ts に KnowledgeArticleProps interface と Result 型の型定義のみを記述。src/backend/contexts/knowledge/domain/models/knowledge-embedding.model.ts に KnowledgeEmbeddingProps interface と型定義のみを記述。src/backend/contexts/knowledge/domain/gateways/knowledge-article.repository.ts に KnowledgeArticleRepository interface（save, findById, findAll, delete）を定義。src/backend/contexts/knowledge/domain/gateways/knowledge-embedding.repository.ts に KnowledgeEmbeddingRepository interface（saveMany, deleteByArticleId, searchSimilar）を定義",
        "wave": 1,
        "done": true
      },
      {
        "id": "knowledge-article-domain-model",
        "description": "src/backend/contexts/knowledge/domain/models/knowledge-article.model.ts に KnowledgeArticle Rich Domain Model を実装。private constructor + ファクトリメソッド create(title, content, sourceType, createdBy, sourceUrl?) でタイトル・本文の空文字バリデーション（Result 型で返す）。reconstruct() で DB からの復元。update(title, content) で更新。src/backend/contexts/knowledge/domain/models/__tests__/knowledge-article.model.test.ts にユニットテスト（create 正常系、バリデーションエラー、update）",
        "wave": 2,
        "done": true
      },
      {
        "id": "knowledge-embedding-domain-model",
        "description": "src/backend/contexts/knowledge/domain/models/knowledge-embedding.model.ts に KnowledgeEmbedding Rich Domain Model を実装。private constructor + ファクトリメソッド create(articleId, chunkIndex, chunkText, embedding) で embedding の次元数（1536）バリデーション（Result 型で返す）。reconstruct() で DB からの復元。src/backend/contexts/knowledge/domain/models/__tests__/knowledge-embedding.model.test.ts にユニットテスト（create 正常系、次元数バリデーションエラー）",
        "wave": 2,
        "done": true
      },
      {
        "id": "openai-embedding-gateway",
        "description": "apps/content-reviewer/package.json に openai パッケージを追加し pnpm install を実行。src/backend/contexts/shared/infrastructure/ai/openai-embedding.gateway.ts に EmbeddingGateway を implements した OpenAIEmbeddingGateway クラスを実装（openai SDK の embeddings.create を呼び出し、model: 'text-embedding-3-small'、1536次元のベクトルを返す）。環境変数 OPENAI_API_KEY を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-knowledge-article-repository",
        "description": "src/backend/contexts/knowledge/infrastructure/repositories/prisma-knowledge-article.repository.ts に PrismaKnowledgeArticleRepository を実装。KnowledgeArticleRepository interface を implements し、Prisma KnowledgeArticle ↔ ドメイン KnowledgeArticle 変換（toDomain / toPrisma private メソッド）。save（upsert）、findById、findAll、delete を実装。共有 prisma-client.ts の PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "prisma-knowledge-embedding-repository",
        "description": "src/backend/contexts/knowledge/infrastructure/repositories/prisma-knowledge-embedding.repository.ts に PrismaKnowledgeEmbeddingRepository を実装。KnowledgeEmbeddingRepository interface を implements し、saveMany（createMany）、deleteByArticleId、searchSimilar（pgvector の <-> 演算子を使ったコサイン距離検索、$queryRaw で実行）を実装。共有 prisma-client.ts の PrismaClient を利用",
        "wave": 2,
        "done": true
      },
      {
        "id": "knowledge-usecases",
        "description": "knowledge context の UseCase 3種を実装。src/backend/contexts/knowledge/application/usecases/create-knowledge-article.usecase.ts（KnowledgeArticleRepository + KnowledgeEmbeddingRepository + EmbeddingGateway を DI。KnowledgeArticle.create → repository.save → EmbeddingGateway.generateEmbedding でチャンク分割なし全文 Embedding → KnowledgeEmbedding.create → embeddingRepository.saveMany）。update-knowledge-article.usecase.ts（findById → update → save → deleteByArticleId → 再 Embedding 生成 → saveMany）。list-knowledge-articles.usecase.ts（repository.findAll）。delete-knowledge-article.usecase.ts（findById → embeddingRepository.deleteByArticleId → repository.delete）。各 UseCase はクラスベース + constructor DI + execute() メソッド",
        "wave": 3,
        "done": true
      },
      {
        "id": "knowledge-usecase-tests",
        "description": "UseCase 4種のユニットテストを作成。src/backend/contexts/knowledge/application/usecases/__tests__/create-knowledge-article.usecase.test.ts（KnowledgeArticleRepository・KnowledgeEmbeddingRepository・EmbeddingGateway をモック、正常系: EmbeddingGateway.generateEmbedding が呼ばれ embeddingRepository.saveMany も呼ばれることを検証）。update-knowledge-article.usecase.test.ts（記事更新 + Embedding 再生成の検証）。list-knowledge-articles.usecase.test.ts。delete-knowledge-article.usecase.test.ts（deleteByArticleId → delete の順序検証）。vitest で全テスト pass を確認",
        "wave": 3,
        "done": true
      },
      {
        "id": "knowledge-presentation",
        "description": "knowledge context の presentation 層を実装。src/backend/contexts/knowledge/presentation/composition/knowledge-article.composition.ts に createListKnowledgeArticlesUseCase / createCreateKnowledgeArticleUseCase / createUpdateKnowledgeArticleUseCase / createDeleteKnowledgeArticleUseCase ファクトリ関数（PrismaKnowledgeArticleRepository + PrismaKnowledgeEmbeddingRepository + OpenAIEmbeddingGateway + prisma を注入）。src/backend/contexts/knowledge/presentation/loaders/knowledge-articles.loader.ts に loadKnowledgeArticles()（UseCase 経由で一覧取得）。src/backend/contexts/knowledge/presentation/actions/create-knowledge-article.action.ts、update-knowledge-article.action.ts、delete-knowledge-article.action.ts に 'use server' Server Actions（FormData → UseCase 呼び出し → revalidatePath('/knowledge')）。開発環境ではダミーユーザー ID を使用",
        "wave": 4,
        "done": true
      },
      {
        "id": "knowledge-ui",
        "description": "shadcn/ui コンポーネント追加（Textarea, ScrollArea 等が未追加なら追加）。src/components/knowledge/knowledge-article-table.tsx（'use client'、一覧テーブル: タイトル・ソース種別・作成日・操作ボタン）、knowledge-article-form-dialog.tsx（'use client'、新規登録/編集兼用の Dialog フォーム: title, content, sourceUrl 入力 → Server Action 呼び出し）、delete-knowledge-article-button.tsx（'use client'、削除確認付きボタン → Server Action 呼び出し）を作成。src/app/(app)/knowledge/page.tsx を更新し、loadKnowledgeArticles() で一覧取得 → KnowledgeArticleTable に props 渡し + 新規登録ボタン配置。e2e/knowledge.spec.ts に /knowledge ページの E2E テスト（一覧表示・新規登録→一覧反映・編集・削除の基本シナリオ）を追加",
        "wave": 5,
        "done": true
      },
      {
        "id": "fix-knowledge-embedding-repository-test-dimensions",
        "description": "prisma-knowledge-embedding.repository.test.ts の sampleEmbeddingValues が Array.from({ length: 3 }, ...) で3次元になっており、KnowledgeEmbedding.create() の1536次元バリデーションで失敗している。修正方針: sampleEmbeddingValues を Array.from({ length: 1536 }, (_, i) => (i + 1) * 0.001) に変更する。また searchSimilar テストの rawRows.embedding も '[0.1,0.2,...（1536次元分）]' に更新する（reconstruct はバリデーションなしなので現状は通るが、正しいテストデータにする）",
        "wave": 8,
        "done": true
      }
    ]
  },
  {
    "milestone": 5,
    "goal": "/knowledge/import で note アカウント名を入力すると NoteScraperGateway 経由で記事一覧が表示され、選択した記事の本文を取得して DB に保存し Embedding を生成できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": true,
    "tasks": [{
        "id": "note-scraper-contract",
        "description": "src/backend/contexts/knowledge/domain/gateways/note-scraper.gateway.ts を新規作成し、NoteArticleSummary 型（title: string, url: string, publishedAt: Date）と NoteScraperGateway interface（fetchArticleList(accountName: string): Promise<NoteArticleSummary[]>、fetchArticleContent(url: string): Promise<{ title: string; content: string }>）を定義する",
        "wave": 1,
        "done": true
      },
      {
        "id": "note-scraper-gateway-impl",
        "description": "必要に応じて apps/content-reviewer/package.json に RSS/XML パース用パッケージ（fast-xml-parser 等）を追加し pnpm install を実行。src/backend/contexts/knowledge/infrastructure/note-scraper.http-gateway.ts に NoteScraperHttpGateway クラスを実装（NoteScraperGateway interface を implements）。fetchArticleList は https://note.com/{accountName}/rss をフェッチして RSS XML をパースし NoteArticleSummary[] を返す。fetchArticleContent は記事 URL をフェッチして HTML から本文テキストを抽出して返す。src/backend/contexts/knowledge/infrastructure/__tests__/note-scraper.http-gateway.test.ts にユニットテストを追加（fetch をモック）",
        "wave": 2,
        "done": true
      },
      {
        "id": "fetch-note-article-list-usecase",
        "description": "src/backend/contexts/knowledge/application/usecases/fetch-note-article-list.usecase.ts に FetchNoteArticleListUseCase を実装（クラスベース + NoteScraperGateway コンストラクタ DI + execute(accountName: string): Promise<NoteArticleSummary[]>）。src/backend/contexts/knowledge/application/usecases/__tests__/fetch-note-article-list.usecase.test.ts にユニットテストを追加（NoteScraperGateway をモック、正常系・空リスト）",
        "wave": 2,
        "done": true
      },
      {
        "id": "import-note-articles-usecase",
        "description": "src/backend/contexts/knowledge/application/usecases/import-note-articles.usecase.ts に ImportNoteArticlesUseCase を実装（NoteScraperGateway + KnowledgeArticleRepository + KnowledgeEmbeddingRepository + EmbeddingGateway をコンストラクタ DI。execute({ selectedUrls: string[], createdBy: UserId }) で各 URL に対して fetchArticleContent → KnowledgeArticle.create(sourceType: 'note') → articleRepository.save → EmbeddingGateway.generateEmbedding → KnowledgeEmbedding.create → embeddingRepository.saveMany を実行）。src/backend/contexts/knowledge/application/usecases/__tests__/import-note-articles.usecase.test.ts にユニットテストを追加（全依存をモック、正常系: fetchArticleContent・save・generateEmbedding・saveMany の呼び出しを検証）",
        "wave": 2,
        "done": true
      },
      {
        "id": "note-import-presentation",
        "description": "src/backend/contexts/knowledge/presentation/composition/knowledge-article.composition.ts を更新して createFetchNoteArticleListUseCase()（NoteScraperHttpGateway を注入）と createImportNoteArticlesUseCase()（NoteScraperHttpGateway + PrismaKnowledgeArticleRepository + PrismaKnowledgeEmbeddingRepository + OpenAIEmbeddingGateway を注入）ファクトリ関数を追加。src/backend/contexts/knowledge/presentation/loaders/note-article-list.loader.ts を新規作成（loadNoteArticles(accountName: string): Promise<NoteArticleSummary[]>、createFetchNoteArticleListUseCase 経由）。src/backend/contexts/knowledge/presentation/actions/import-note-articles.action.ts を新規作成（'use server' Server Action、FormData から selectedUrls と accountName を受け取り ImportNoteArticlesUseCase を呼び出し revalidatePath('/knowledge') を実行）",
        "wave": 3,
        "done": true
      },
      {
        "id": "note-import-ui",
        "description": "src/components/knowledge/note-article-list.tsx を新規作成（'use client'、NoteArticleSummary[] を props で受け取りチェックボックス付きテーブルを表示し選択記事の URL を import-note-articles.action.ts に送信する form、ローディング状態対応）。src/app/(app)/knowledge/import/page.tsx を更新（Server Component、searchParams.accountName があれば loadNoteArticles() を呼んで NoteArticleList コンポーネントに渡す。アカウント名入力フォームを配置し送信で同ページに ?accountName=xxx リダイレクト）。e2e/knowledge-import.spec.ts を新規作成し /knowledge/import ページの E2E テスト（アカウント名入力フォーム表示・送信後に記事一覧が表示されること・記事選択して保存後に /knowledge ページに遷移し記事が追加されていることを確認する基本シナリオ）を追加",
        "wave": 4,
        "done": true
      },
      {
        "id": "verify-milestone5",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test を実行し全て成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗・E2E テスト失敗があれば全て修正する",
        "wave": 5,
        "done": false
      },
      {
        "id": "fix-domain-model-serialization",
        "description": "E2E テストが 'Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.' エラーで失敗する。原因: loadExpressionRules()（expression-rule.loader.ts）と loadKnowledgeArticles()（knowledge-articles.loader.ts）が ExpressionRule / KnowledgeArticle クラスインスタンスをそのまま返しており、page.tsx が Client Component（ExpressionRuleTable, KnowledgeArticleTable）に props として渡す際に Next.js のシリアライズエラーが発生する。修正方針: 各 loader で Domain Model を plain object の DTO に変換して返す。(1) ExpressionRuleProps に相当する plain type（ExpressionRuleDto）を定義し、expression-rule.loader.ts で ExpressionRule インスタンスを { id: rule.id, ngExpression: rule.ngExpression, ... } のスプレッド/明示変換でプレーンオブジェクトに変換して返す。(2) 同様に KnowledgeArticleDto を定義し、knowledge-articles.loader.ts でも変換する。(3) ExpressionRuleTable と KnowledgeArticleTable の props 型を DTO 型に変更し、型整合性を確認する。DTO 型は presentation 層（loaders ディレクトリ内または別の types ファイル）に配置する",
        "wave": 6,
        "done": true
      }
    ]
  },
  {
    "milestone": 6,
    "goal": "/checks/new でテキストを入力して送信すると、AIGateway による段落分割→5種のチェック（ファクトチェック・ナレッジ整合性・表現ルール適合・炎上リスク・文章クオリティ）が並列実行され、SSE で進捗がリアルタイム表示され、完了後 /checks/[id] で結果詳細（セグメントごとの指摘・severity・修正提案）を確認できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": [
      {
        "id": "content-check-contracts",
        "description": "content-check context の全契約定義（W2以降の全タスクが参照する）。(1) src/backend/contexts/shared/domain/models/ に ContentCheckId・ContentSegmentId・CheckResultId の各 branded type（createXxxId ファクトリ + UUID バリデーション）を追加。(2) src/backend/contexts/shared/domain/gateways/ai.gateway.ts を新規作成（AIGateway interface: generate(prompt, options?): Promise<string>、generateWithWebSearch(prompt, options?): Promise<string>、generateStream(prompt, options?): AsyncGenerator<string> + GenerateOptions 型）。(3) src/backend/contexts/content-check/domain/models/content-check.model.ts に ContentCheckProps interface・CheckStatus type ('pending'|'processing'|'completed'|'failed')・Result型・ContentCheck クラス骨格（create/reconstruct/startProcessing/complete/fail のメソッドシグネチャ、ボディは throw new Error('not implemented')）を定義。(4) content-segment.model.ts に ContentSegmentProps + ContentSegment クラス骨格を定義。(5) check-result.model.ts に CheckType type ('fact_check'|'knowledge_consistency'|'expression_rule'|'risk_assessment'|'quality')・Severity type ('info'|'warning'|'error')・CheckResultProps・CheckResult クラス骨格を定義。(6) src/backend/contexts/content-check/domain/gateways/ に ContentCheckFilter 型・ContentCheckRepository（save, findById, findAll(filter)）・ContentSegmentRepository（saveMany, findByContentCheckId）・CheckResultRepository（saveMany, findBySegmentId, findByContentCheckId）・ExpressionRuleProvider（findActiveRules(): Promise<{ngExpression: string; recommendedExpression: string}[]>）・KnowledgeSearchGateway（searchSimilar(embedding: number[], limit: number): Promise<{chunkText: string}[]>）の各 interface ファイルを新規作成する",
        "wave": 1,
        "done": true
      },
      {
        "id": "content-check-domain-models",
        "description": "content-check context のドメインモデル実装とドメインサービス。(1) src/backend/contexts/content-check/domain/models/content-check.model.ts を実装: private constructor + create(source, originalText, userId?) で空文字・30000字上限バリデーション（Result型返却）・reconstruct() で DB復元・startProcessing()/complete()/fail() でステータス遷移を実装。(2) content-segment.model.ts: create(contentCheckId, segmentIndex, text) + reconstruct() を実装。(3) check-result.model.ts: create(segmentId, checkType, severity, message, suggestion?) + reconstruct() を実装。(4) src/backend/contexts/content-check/domain/services/content-review.service.ts を新規作成: ContentReviewService クラス（summarize(results: CheckResult[]): {error: number, warning: number, info: number} で severity 別カウントを集計）。(5) src/backend/contexts/content-check/domain/models/__tests__/ に各モデルのユニットテスト（create 正常系・バリデーションエラー・ステータス遷移）を追加",
        "wave": 2,
        "done": false
      },
      {
        "id": "anthropic-ai-gateway",
        "description": "Anthropic Claude API の AIGateway 実装。apps/content-reviewer/package.json に @anthropic-ai/sdk を追加し pnpm install を実行。src/backend/contexts/shared/infrastructure/ai/anthropic-ai.gateway.ts に AnthropicAIGateway implements AIGateway を実装: generate() は messages.create() で claude-sonnet-4-6 を呼び出し最初の text ブロックを返す、generateWithWebSearch() は web_search_20250305 ツールを tools に渡して messages.create() を呼び出し最終 text ブロックを返す、generateStream() は messages.stream() を使い AsyncGenerator で text_delta チャンクを yield する。ANTHROPIC_API_KEY 環境変数を利用。src/backend/contexts/shared/infrastructure/ai/__tests__/anthropic-ai.gateway.test.ts に @anthropic-ai/sdk をモックしたユニットテスト（generate・generateWithWebSearch の正常系）を追加",
        "wave": 2,
        "done": false
      },
      {
        "id": "content-check-repositories",
        "description": "content-check context の Prisma Repository 実装3種。src/backend/contexts/content-check/infrastructure/repositories/ に以下を新規作成: (1) prisma-content-check.repository.ts: PrismaContentCheckRepository implements ContentCheckRepository（save は upsert、findById、findAll(filter) は ContentCheckFilter に応じた where 条件付き検索 + toDomain/toPrisma 変換）。(2) prisma-content-segment.repository.ts: PrismaContentSegmentRepository implements ContentSegmentRepository（saveMany は createMany、findByContentCheckId + toDomain 変換）。(3) prisma-check-result.repository.ts: PrismaCheckResultRepository implements CheckResultRepository（saveMany は createMany、findBySegmentId、findByContentCheckId + toDomain 変換）。各 Repository は共有 prisma-client.ts の PrismaClient を利用し Prisma 型 ↔ ドメインモデル変換を行う",
        "wave": 2,
        "done": false
      },
      {
        "id": "cross-context-providers-impl",
        "description": "content-check context 内から他 Context のデータを参照するための Gateway 実装2種（Context 間の直接 import を回避）。(1) src/backend/contexts/content-check/infrastructure/prisma-expression-rule.provider.ts: PrismaExpressionRuleProvider implements ExpressionRuleProvider。findActiveRules() で prisma.expressionRule.findMany({ where: { isActive: true } }) を直接呼び出し { ngExpression, recommendedExpression }[] に変換して返す。expression-rule context は一切 import しない。(2) src/backend/contexts/content-check/infrastructure/prisma-knowledge-search.gateway.ts: PrismaKnowledgeSearchGateway implements KnowledgeSearchGateway。searchSimilar(embedding, limit) で pgvector の <-> コサイン距離演算子を使った $queryRaw で knowledge_embeddings テーブルを検索し { chunkText: string }[] を返す。knowledge context は一切 import しない",
        "wave": 2,
        "done": false
      },
      {
        "id": "execute-content-check-usecase",
        "description": "ExecuteContentCheckUseCase の実装（Milestone 6 の中核処理）。src/backend/contexts/content-check/application/usecases/execute-content-check.usecase.ts: コンストラクタ DI（AIGateway, EmbeddingGateway, ContentCheckRepository, ContentSegmentRepository, CheckResultRepository, ExpressionRuleProvider, KnowledgeSearchGateway）。execute({ source, originalText, userId?, onProgress? }): (1) ContentCheck.create → save（status: pending）、(2) AIGateway.generate でセマンティック段落分割プロンプト送信 → JSON パース → ContentSegment 群生成 → saveMany → onProgress('segments_created', {total})、(3) status を processing に更新して save、(4) 各セグメントに対して Promise.all で5種チェックを並列実行（ファクトチェック: generateWithWebSearch / ナレッジ整合性: EmbeddingGateway.generateEmbedding → KnowledgeSearchGateway.searchSimilar → AIGateway.generate / 表現ルール: ExpressionRuleProvider.findActiveRules → AIGateway.generate / 炎上リスク: AIGateway.generate / 文章クオリティ: AIGateway.generate）、各チェック開始・完了時に onProgress('check_started'/'check_completed') を送出、(5) CheckResult[] → saveMany、(6) ContentCheck.complete() → save → onProgress('completed', {contentCheckId, summary})、エラー時は ContentCheck.fail() → save → onProgress('error')。src/backend/contexts/content-check/application/usecases/__tests__/execute-content-check.usecase.test.ts に全依存モックのユニットテスト（正常系: 全 Gateway・Repository の呼び出し検証、エラー系: AIGateway 失敗時の ContentCheck.fail() 確認）を追加",
        "wave": 3,
        "done": false
      },
      {
        "id": "get-content-check-detail-usecase",
        "description": "GetContentCheckDetailUseCase の実装。src/backend/contexts/content-check/application/usecases/ に以下を新規作成: (1) content-check-detail.dto.ts: ContentCheckDetailDto 型（plain object: { id, source, status, originalText, createdAt, segments: { id, segmentIndex, text, results: { id, checkType, severity, message, suggestion | null }[] }[], summary: { error: number, warning: number, info: number } }）を定義。(2) get-content-check-detail.usecase.ts: コンストラクタ DI（ContentCheckRepository, ContentSegmentRepository, CheckResultRepository）。execute(id: string): ContentCheck + 全 segments + 各 segment の results を取得・組み立て → ContentCheckDetailDto を返す（ID 存在しない場合は Error を throw）。(3) __tests__/get-content-check-detail.usecase.test.ts: 全 Repository をモック、正常系（DTO の構造・段落/結果の組み立て検証）・存在しない ID でのエラー確認",
        "wave": 3,
        "done": false
      },
      {
        "id": "content-check-composition-and-loader",
        "description": "content-check context の Composition Root と Loader 実装。(1) src/backend/contexts/content-check/presentation/composition/content-check.composition.ts を新規作成: createExecuteContentCheckUseCase()（AnthropicAIGateway + OpenAIEmbeddingGateway + PrismaContentCheckRepository + PrismaContentSegmentRepository + PrismaCheckResultRepository + PrismaExpressionRuleProvider + PrismaKnowledgeSearchGateway を注入）と createGetContentCheckDetailUseCase()（PrismaContentCheckRepository + PrismaContentSegmentRepository + PrismaCheckResultRepository を注入）のファクトリ関数を定義。(2) src/backend/contexts/content-check/presentation/loaders/get-content-check-detail.loader.ts を新規作成: loadContentCheckDetail(id: string): Promise<ContentCheckDetailDto> を createGetContentCheckDetailUseCase 経由で取得して返す",
        "wave": 4,
        "done": false
      },
      {
        "id": "execute-content-check-sse",
        "description": "SSE ストリーミングエンドポイントの実装。src/app/api/checks/execute/route.ts を新規作成（POST API Route）: リクエストボディから originalText・source を取得、ReadableStream を生成し SSEフォーマット（data: ${JSON.stringify(event)}\\n\\n）で onProgress コールバックのイベント（segments_created, check_started, check_completed, completed, error）を書き出す。createExecuteContentCheckUseCase() を content-check.composition.ts から取得して execute() を呼び出す。開発環境（NODE_ENV=development）ではダミーユーザー ID を使用、本番環境では Supabase Auth セッションから userId を取得。レスポンスは Content-Type: text/event-stream, Cache-Control: no-cache で返す",
        "wave": 5,
        "done": false
      },
      {
        "id": "checks-new-page-ui",
        "description": "/checks/new ページの UI 実装。(1) src/components/checks/check-form.tsx を新規作成（'use client'）: shadcn/ui Textarea でテキスト入力（30000字カウンタ表示）、送信ボタン押下で fetch('/api/checks/execute', { method: 'POST', body: JSON.stringify({ originalText, source: 'web' }) }) を呼び出し ReadableStream reader で SSE イベントを consume、segments_created 受信後に段落数を表示、check_started/check_completed 受信でチェック種別（5種）ごとのステータスバッジ（waiting→running→done）をリアルタイム更新、completed 受信後に router.push(`/checks/${contentCheckId}`) でリダイレクト、error 受信時はエラーメッセージ表示。(2) src/app/(app)/checks/new/page.tsx（Server Component）を更新し CheckForm コンポーネントをレンダリング",
        "wave": 5,
        "done": false
      },
      {
        "id": "checks-detail-page-ui",
        "description": "/checks/[id] 詳細ページの UI 実装。(1) src/components/checks/check-result-summary.tsx を新規作成（Server Component）: error/warning/info の件数をバッジ表示するサマリー統計コンポーネント。(2) src/components/checks/check-result-segment.tsx を新規作成（Server Component）: セグメントテキストと そのセグメントの CheckResult 一覧（checkType ラベル・severity バッジ（error=red, warning=yellow, info=blue）・message・suggestion）を表示。(3) src/app/(app)/checks/[id]/page.tsx を更新（Server Component）: loadContentCheckDetail(params.id) で ContentCheckDetailDto を取得し CheckResultSummary と全 CheckResultSegment コンポーネントを表示（ID 不正時は notFound()）。(4) e2e/checks.spec.ts を新規作成: /checks/new でテキスト入力・送信 → SSE 進捗表示（段落数・チェック種別ステータス）→ 完了後 /checks/[id] へリダイレクト → セグメントごとの結果詳細が表示されることを確認する基本 E2E シナリオを追加",
        "wave": 5,
        "done": false
      },
      {
        "id": "verify-milestone6",
        "description": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test を実行し全て成功することを確認。Biome lint エラー・TypeScript 型エラー・ビルドエラー・テスト失敗・E2E テスト失敗があれば全て修正する",
        "wave": 6,
        "done": false
      }
    ]
  },
  {
    "milestone": 7,
    "goal": "ダッシュボード（/）に過去のチェック履歴一覧が表示され、ソース種別（Web / Slack）・ステータス・実行日時でフィルタリングでき、各行クリックで /checks/[id] の詳細ページに遷移できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test && pnpm exec playwright test",
    "done": false,
    "tasks": []
  },
  {
    "milestone": 8,
    "goal": "/api/slack/events で Slack Events API の Webhook を受信し、Slack 署名検証・url_verification 対応の上、@sns-checker メンション時に waitUntil でバックグラウンドチェックを実行し、完了後にスレッドへ結果サマリーと /checks/[id] のパーマリンクを返信できる",
    "verification": "pnpm lint && pnpm typecheck && pnpm build && pnpm test",
    "done": false,
    "tasks": []
  }
]